---
title: "1. Analyses"
author: "Lauke"
date: "28/01/2022"
output: html_document
---
```{r load in subsetted QQQ data}
load("~/GitHub/Master_Thesis/Analyses/Workspaces/QQQbook1_math.Rdata")
load("~/GitHub/Master_Thesis/Analyses/Workspaces/sel_age.Rdata")

```


```{r Libraries}
library(haven)
library(MCMCpack) #needed for PSM procedure MCMClogit function
library(dplyr)
library(rjags)

#require(devtools)
#install_version("optmatch", version = "0.9-17", repos = "http://cran.us.r-project.org")
library(optmatch)
```

Step 1: obtain a propensity score distribution for each pupil. 

Variables to estimate PS on - need to relate to country membership, need some input for this. NB: must be variables that were measured before treatment assignment (Kaplan and Chen 2012)
- ESCS
- nr of years after start ISCED 1 (not included for now)
- age
- grade: captures whether the student is in the countryâ€™s modal grade (value of 0), or the number of grade below or above the modal grade in the country.


```{r Prep data step 1}
#Merge selection age info with QQQ data
step1_dat <- inner_join(sel_age[,c(1,2,4,5)], QQQbook1_math, by = "CNT") %>% 
  filter(OECD == 1)  %>% #select only OECD members
  filter(!is.na(ESCS)) %>% #only complete data points
  filter(!is.na(GRADE)) %>% 
  select(CNTSTUID, selection_age, nr_schooltypes, AGE, ESCS, GRADE, ISCEDL, HISCED) #select used vars only 

table(step1_dat$selection_age)

step1_dat$group <- ifelse(step1_dat$selection_age <= 15, 0, 1) #if selection age < or = 12, group 0, >12 group 1.

rm(QQQbook1_math)
```

```{r }
library(tableone)
table1 <-
  CreateTableOne(
    vars = c(
      "nr_schooltypes",
      "ESCS", 
      "GRADE", 
      "ISCEDL", 
      "HISCED"
      ),
strata = "group",
data = step1_dat,
test = FALSE
  )

print(table1, smd = T)
```

Just running with only numeric variables for now. 


```{r Estimate posterior coefficients for alpha & betas}
set.seed(123)
posterior <- MCMClogit(group ~ as.numeric(GRADE) + as.numeric(AGE) + as.numeric(ESCS), mcmc = 2000, burnin = 1000, thin = 2, data = step1_dat)

plot(posterior) #convergence is fine
summary(posterior)
```

```{r Estimate propensity scores for each pupil based on posterior samples of alpha and beta}
#create matrix containing all independent variables + intercept (1)
X_matrix <- step1_dat %>% 
  mutate(constant = 1) %>% #add column to be multiplied by intercept
  dplyr::select(constant, GRADE, AGE, ESCS) %>% #select intercept + Xvars
  t() %>% #transpose to fit posterior object (col = pupils, row = vars)
  as.matrix() #store as matrix

#multiply the obtained posterior estimates with IV's to obtain propensity scores
prop_scores <- exp(posterior %*% X_matrix) / #logistic regression, see manuscript equation 3.
  (1 + exp(posterior %*% X_matrix)) #col = pupils, row = n.iter prop scores

colnames(prop_scores) <- step1_dat$CNTSTUID #give cols student ID names

hist(colMeans(prop_scores)) # skewed distribution
mean(colMeans(prop_scores)) #mean propensity scores is 0.78
table(step1_dat$group) #about 75% in group 1, so that makes sense. consider oversampling later
```

```{r Check which students with prop scores belong to which group}
prop_scores_by_group <- data.frame(mean_propscores = colMeans(prop_scores), #mean ps per student
                         CNTSTUID = as.numeric(colnames(prop_scores))) %>%  #extract student ID
  left_join(step1_dat %>% dplyr::select(CNTSTUID, group)) #join ps and student ID with group membership

# Create separate data files for T = 1 vs T = 0 
group0 <- prop_scores_by_group %>% filter(group == 0)
group1 <- prop_scores_by_group %>% filter(group == 1)
mean(group0$mean_propscores) #0.767151
mean(group1$mean_propscores) #0.777821 very little difference in PS per group


# Create histograms, then plot one and add the other: 
hist0 <- hist(group0$mean_propscores, breaks=30, plot=FALSE)
hist1 <- hist(group1$mean_propscores, breaks=30, plot=FALSE)
plot( hist1, col=rgb(0,0,1,1/4), xlim=c(0,1), 
        xlab="Propensity score", 
      main="Histogram of propensity scores")  
plot( hist0, col=rgb(1,0,0,1/4), xlim=c(0,1), add=T) 

```
NB: the range and overlap is fine - I just didn't select very good predictors of the PS. OR actually there are just more T = 1 than T = 0... sooooo...


2. Obtain an estimate for the treatment effect

a. Match sub-samples based on each of m.iter sets of propensity scores

Conceptually, the result of a call match_on is a treatment-by-control matrix of distances.
```{r Create distance matrices for each iteration of PS, cache = T}
options("optmatch_max_problem_size" = Inf) #expand memory for problem size

#tiny trial: 
trialdat <- step1_dat[c(1:10,500:520),] #select a few T = 1 and T = 0
rownames(trialdat) <- as.character(trialdat$CNTSTUID) #make rownames STUID for match matrices
ps1 <- prop_scores[1,c(1:10,500:520)] #subset the corresponding propensity scores
str(ps1) #check format

trialmatchobj <- match_on(group ~ ps1, data = trialdat) #match on ps 
View(trialmatchobj) #check col & rownames

#fullmatch;
trialmatches <- fullmatch(trialmatchobj, data = trialdat)
print(trialmatches, grouped = T)

trialmatches_p <- pairmatch(trialmatchobj, controls = 1, remove.unmatchables = T, data = trialdat)
print(trialmatches_p, grouped = T)

#Now the real deal: 
rownames(step1_dat) <- as.character(step1_dat$CNTSTUID) #make rownames STUID for match matrices

#check functionality on first iteration:
matchobj <- match_on(group ~ prop_scores[1,], data = step1_dat)

gc() #clean out unused memory
library(doSNOW) 
nclust <- parallel::detectCores() - 1
cl <- makeCluster(nclust)
registerDoSNOW(cl)

#add progress bar
pb <- txtProgressBar(min = 0, max = 5, style = 3)
opts <- list(progress = function(n) setTxtProgressBar(pb,n))

#export objects to newly created R seshs
clusterExport(cl, c('step1_dat'))

distance_matrices <- foreach(i = 1:5, .options.snow = opts, .packages = c("optmatch")) %dopar% {
  match_on(group ~ prop_scores[i,], data = step1_dat)@.Data
}

stopCluster(cl)

saveRDS(distance_matrices, file = "Workspaces/distance_matrices.Rdata")
#rm(distance_matrices) # --> new file 
```

```{r Full match based on each of the distance matrices}
#trial on 1st distance matrix only:
matches <- fullmatch(distance_matrices[[1]], data = step1_dat)
matched_dat <- cbind(step1_dat, matches = matches)

#trial with pairmatch instead
pmatches <- pairmatch(distance_matrices[[1]], data = step1_dat)
summary(pmatches)
print(pmatches, grouped = T)
pmatched_dat <- cbind(step1_dat, matches = pmatches) %>% #add match info to main dataset
  filter(!is.na(matches)) #filter out non-matched units

detach("package:doSNOW", unload = T) #b/c it masks a shit tonne

library(parallel)

memoryopts <- options("optmatch_max_problem_size" = Inf) #expand memory for problem size
cl <- makeCluster(nclust)
clusterExport(cl, c('distance_matrices', 'step1_dat', 'memoryopts')) #can we export memory size settings? 
clusterEvalQ(cl, c(library(optmatch)))

#matches <- lapply(distance_matrices, function(x) {fullmatch(x, data = step1_dat)}) # dit werkt wel (geen cluster runnen!)
matches <- parLapply(cl, distance_matrices, function(x) {fullmatch(x, data = step1_dat)}) # dit werkt  niet -> zie error below

stopCluster(cl)

str(matches[[1]])
print(matches[[1]], grouped = T)
```

Error: Error in checkForRemoteErrors(val) : 
  3 nodes produced errors; first error: Maximum matching problem may have only 1e+07 - (nrows + ncols + 2) finite entries; 12957311 too many. Set 'options("optmatch_max_problem_size" = Inf)' to disable this check.


Now we have 1000 different sets of matched units to pour into the analyses that estimates the treatment effect. First, we have to define the Y-variable on which we're regressing: ability. Draw those back from QQQbook1_math.

```{r Add ability estimates to dataset}
#obtain 10 plausible values on the MATH items per pupil from the original dataset
PVs <- QQQbook1_math %>% select(CNTSTUID, starts_with("PV") & ends_with("MATH"))
PVs$ability <- rowMeans(PVs[,2:11]) #compute ability estimate per pupil

#add ability estimate to the dataset for step 2
step2_dat <- inner_join(pmatched_dat, PVs[,c(1,12)], by = "CNTSTUID") 
```

```{r Compute treatment effect [trial on paired data]}
posterior_treat <- MCMCregress(ability ~ as.factor(group) + as.numeric(GRADE) + as.numeric(AGE) + as.numeric(ESCS), mcmc = 2000, burnin = 1000, data = step2_dat)

plot(posterior) #convergence is fine
summary(posterior) #unclear why estimate for group has disappeared

testdat <- step2_dat %>% select(CNTSTUID, group, ability, GRADE, AGE, ESCS)
testpost <- MCMCregress(ability ~ as.factor(group) + as.numeric(GRADE) + as.numeric(AGE), mcmc = 2000, burnin = 1000, data = testdat)
plot(testpost)
summary(testpost) #here group estimate is fine
```






